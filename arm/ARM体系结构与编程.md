# ARM体系结构与编程
## ARM体系机构版本
- 其中会有各个变种（不同变种的本质区别就是是否支持特殊的指令）
  - T变种：支持Thumb指令集
    > thumb指令集有局限：
    > 1. 完成同样工作需要更多指令；
    > 2. 没有包含进行异常处理的指令，因此在异常处理的低级处理中，需要arm指令。
  - M变种：支持长乘法指令
  - E变种：支持增强型DSP指令
  - J变种：支持Java加速器Jazelle
  - SIMD变种：支持多媒体功能
## ARM处理器运行模式
  - 七种运行模式
    ![新建位图图像.bmp](attachments\1d676759.bmp)
    - 其中除了用户模式，其他都是特权模式。除了系统模式和用户模式其他的五种都是异常模式，通过异常状态进入。用户模式不能进行模式切换。
    - 系统模式不是通过异常进入，他和用户模式有完全一样的寄存器，但是系统模式可以访问所有的资源，也可以直接进行处理器模式切换。
  - 各种模式下的寄存器
 ![新建位图图像 (2).bmp](attachments\aa94f919.bmp)
    - 31个通用寄存器，都是32bit
    - 6 个状态寄存器都是32bit但是只用了12bit
    - 不同模式下用到的寄存器是不同的，有些状态用到的寄存器是一样的比如用户模式和系统模式
    - unbanked registers R0~R7，所有模式下用到的都是一样的。
    - Banked registers R8~R14；
      - 在firq的模式下不需要进行保护和恢复中断现场的指令（压栈出栈操作），因此非常迅速；R13寄存器用来栈指针。
      - 在arm中是习惯用法，在thumb指令中有强制使用R13作为栈指针。
      - 每一种异常模式都有自己的栈指针，进行模式切换时（切出firq模式除外）都需要将寄存器的值压栈到栈指针的所指向的地址，使异常处理不会破坏中断的程序的现场。
      - R14 (LR)其中存放子程序返回地址，当通过BL或BLX跳转的时候，R14被设置好返回地址；返回：【mov pc, lr或者bx lr】
    - 程序计数器R15(PC)
      - **arm采用流水线机制，PC指向当前指令的下两条指令。**
    - 程序状态寄存器（CPSR）
    ![新建位图图像 (3).bmp](attachments\f568fa42.bmp)
      - N Z C V Q: 表示条件标志位，当发生固定情况时各个位会生效。
      - I F T M[4:0]: 表示控制位，控制arm处理器的状态。
    - 三种控制程序执行流程
      - 正常执行指令，每执行一条ARM指令，程序寄存器（PC）加4，每执行一条Thumb指令，PC的值加2
      - 通过跳转指令，B跳转不保存返回地址，BL跳转并保存子程序返回地址，BX在跳转过程中根据目标地址最低位将程序状态切换到Thumb状态，BLX跳转到目标地址，保存子程序返回值，根据目标地址最低位切换Thumb指令。
      - 异常发生后，系统执行完当前指令后，跳转到相应异常中断处理程序，在进入异常中断处理程序时要保护被中断的现场。在异常中断处理程序退出时，要恢复中断程序的执行现场。
## Arm中断类型
![新建位图图像 (4).bmp](attachments\f470a737.bmp)
  - Arm中断响应过程
    - 保存当前状态、中断屏蔽以及各条件标志位。【通过将CPSR中的内容保存到要执行的异常中断对应的SPSR，各个异常中断有自己的物理SPSR】
    - 设置当前CPSR中的相应位，使处理器进入相应模式,禁止相同中断。
    - 将lr_mode设置成返回地址
    - 将PC设置成该异常中断的中断向量地址，跳转到异常中断处执行
    > 总结：相对应的需要保存的现场都保存到跳转到的mode中的相应的寄存器中。CPSR->SPSR_mode, 中断前PC(下一条指令放入到)lr_mode
```c
r14_exp_mode = return link
spsr_ep_mode = cpsr
cpsr[4:0] = ep_number
cpsr[5] = 0 //set arm instruct
if (ep_mode== reset or fiq)
  cpsr[6] = 1//disable fiq
cpsr[7] = 1//diable irq
pc = ep_vector_addr//jump 
```
  - Arm从中断中返回
    - 将spsr_mode寄存器中的内容复制到cpsr
    - 把lr_mode寄存器中的内容复制到PC中，当异常发生时，程序计数器PC所指的位置对于各种不同的异常中断是不同的。同样对于各种异常，返回地址也是不同的。
## ARM存储系统
  - 字的长度是不一定的，在64bit机器侠是64bit，在32bit机器下字是32bit，在16bit机器下字是16bit
  - 在不同状态（arm状态，thumb状态下）如果不能做到字对齐和半字对齐那么结果是不可预知，或者最低两位（arm状态）或者一位（thumb状态）会被忽略。
## ARM指令
![新建位图图像 (5).bmp](attachments\9a1ef98a.bmp)
  - 注意： 
    - (1)LDR R0, [R1], #4; 和 (2)LDR R0, [R1, #4] : (1) 将R1中的内存地址的数据加载到R0，然后R1=R1+4, (2)将R1中的内存地址加4后的内存中的数据拷贝到R0。
    - (1)LDR R0, [R1, #4]!;和 (2)LDR R0, [R1, #4];:都是要将R1中的内存的数值加4的数值再拷贝到R0中，然后R1=R1+4，(2)没有R1=R1+4的操作
## Thumb指令集
  - 对于存储系统数据总线为16bit的应用系统，ARM提供了thumb指令集，thumb指令集是ARN指令集的一个子集重新编码得到，指令长度16bit。当处理器在执行arm指令时，称处理器处于arm状态，当处理器在执行thumb指令时，称处理器为thumb状态。
  - thumb指令集中没有操作cpsr和spsr的指令。
## ARM汇编
### 伪操作   
- symbol definition伪操作 
- data definition伪操作
- assembly control伪操作
- frame description伪操作
- reporting伪操作
- miscellaneous伪操作

##
## ARM中存储管理协处理器CP15
- Arm中存储管理一般都是用协处理器CP15来管理，处了协处理器还会用到MMU，通过页表来管理。
- CP15 中有16个32bit寄存器，对于某些寄存器，肯定对应多个物理寄存器，通过指令来区分。
### 访问CP15寄存器的指令
- MCR： Arm寄存器到协处理器寄存器的数据传送指令。
- MRC： 协处理器寄存器到Arm寄存器。
- MCR指令和MRC指令只能在处理器模式是系统模式时执行，在用户模式下执行该指令会出未定义指令错误。在用户模式下要访问CP15一般通过SWI调用完成相应功能。
- 例子：mcr p15, 0, r4, c1, c0, 0;将Arm寄存器R4的值放到CP15的C1中。opcode 1, opcode 2都是0，opcode 2可以指定读到的不同物理地址的寄存器.
### CP15中的寄存器
![新建位图图像 (13).bmp](attachments\5937300a.bmp)

## 存储管理单元MMU
- 页表是实现内存管理的重要手段，位于内存中，每一行对应于虚拟存储空间的一页，该行还包含了该虚拟内存的对应的物理内存的地址，访问权限，缓冲特性。
- CP15的寄存器C2用来保存页表基地址。
- 由于在一段时间内，对页表的访问只在局部很少的几个单元中，采用一个容量小访问速度快的存储器来存放当前的地址变换条目（页表中的一行），这个小容量的页表叫做TLB。
- 当cpu需要访问内存时，现在tlb中找到需要地址变幻的条目，如果找不到就用内存中的页表进行查询。并把结果添加进tlb中。
- 当tlb中的内容需要全部清除，mmu提供了相关的硬件支持的操作通过cp15的c8寄存器用来清除tlb
- mmu可以将某些地址变换条目锁定在tlb中，从而使地址变幻的很快。寄存器c10用来控制锁定tlb的内容。
- arm支持的存储块大小：
  - section：1M
  - large pages：64kb
  - small pages：4kb
  - tiny pages：1kb
- mmu采取两级页表映射
  - 一级页表包含一段为单位的地址变换条目，以及指向二级页表的指针
  - 二级页表中包含大页和小页，其中二级页表也包含以极小页为单位的条目
  - 二级页表有两种粒度：粗粒度和细粒度。粗粒度以4KB为单位进行地址映射，细粒度以1kB进行映射。（粗粒度：每个条目是4KB，细粒度：每个条目是1KB），二级页表定义了1MB大小的虚拟空间映射关系。
![新建位图图像 (14).bmp](attachments\38bc3dec.bmp)

## 高速缓冲存储器和写缓冲区
高速缓冲存储器（cache）和写缓冲区（write buff)位于cpu和主存储之间，主要用来提高存储系统性能。cache主要优化读。write buff主要优化写。
- cache主要与存储器之间以块（cache line）为单位进行交换。
- 写缓冲区是由一些高速的存储器组成，主要优化向存储器的写。
### cache的工作原理
![新建位图图像 (15).bmp](attachments\2f5067ab.bmp)
cpu送来主存储器的地址，放到主存储器的寄存器中，通过地址变换把主存储器的块号B变换成cache的块号b并放入cache的寄存器中。同时将块内地址W作为cache的块内地址w装入cache的地址寄存器中。

### cache地址映射和变换方法
在cache中，地址映射就是把主存的地址空间映射到cache空间。（把主存中的内容按照某种方式装入到cache）
### 快速上下文切换
通过修改不同进程的虚拟地址避免在进程切换时造成虚拟地址到物理地址的重映射，从而提高系统性能。
- 快速上下文切换技术原理
通常情况下两个进程占用的虚拟地址空间有重叠，系统在两个进程之间进行切换时，必须进行虚拟地址到物理地址的重映射。而虚拟地址到物理地址重映射，涉及到重建MMU中的页表，而且cache和tlb中的内容都必须使无效。这些操作都需要很大开销。FCSE（快速上下文切换技术）的引入避免了该开销。
快速上下文切换将各个进程的虚拟空间变换到了不同的虚拟空间。这样在进行进程切换是就不需要进行虚拟地址到物理地址的重映射了。
在arm系统中，4G空间被分成了128个进程空间快，每个进程空间32M，每个进程空间可以包含一个进程，该进程的可以使用的虚拟地址空间为0x00000000~0x01ffffff这个地址范围就是cpu可以看到的地址空间。128个进程编号从0~127，编号为i的进程实际使用的虚拟地址空间为i\*0x02000000到i\*0x02000000+0x01ffffff，这个虚拟地址空间是系统除了cpu之外的其他部分看到的进程所占用的虚拟空间。

### 存储系统相关的程序设计指南
- 当用户读取PC寄存器的值的时候，返回的是下边第2条指令的地址，对于arm指令来说当前是PC+8，对于thumb指令来说是当前PC+4
- 预取指令不一定会执行，比如遇到了中断异常或者只领了跳转，预期的指令都将被抛弃。

### ATPCS概述
PCS是与体系结构密切相关的，直接涉及编译器如何使用处理器提供的应用寄存器，如编译器使用什么寄存器作为栈指针，利用哪些寄存器作直接传参等。值得注意的是，没有谁规定说PCS是必须这样而不是那样的。它是应用相关的。任何一个操作系统和应用可以处于它自身的考虑定义自己的PCS。当然，如果那样，也必须有自己的编译器。而实际上，在一个处理器设计时，都会有某种假设，所以PCS某种程度上应该是一样的。
寄存器使用规则：
- R0~R3来传递参数。被调用的子程序返回前无须恢复寄存器R0~R3
- 在子程序中，使用寄存器R4~R11来保存局部变量，如果在子程序中用到了寄存器，子程序在进入时必须保持这些寄存器的值，返回时必须回复这些寄存器的值。在thumb指令中通常只用R4~R7来保存局部变量。
- R12 用作子程序间的连接代码。
- R13 用做栈指针sp，不能用作其他用途，寄存器sp在进入子程序时和退出子程序时的值必须相等。
- R14 lr寄存器，用于保存返回地址。
- R15 是程序计数器，记作pc，不能用作其他用途。PC总指向正在取指的指令（取指->译码->执行），如果返回的时候返回到PC的位置，那么中间就有一个命令没有执行。
arm和thumb程序混合使用时必须用arm的场合:
- 强调速度的场合。少量32位内存，少量指令完成相同的事情。
- 使用或者禁止中断和异常
- 当处理器进入异常中断处理程序时程序状态自动切换到arm状态，即在中断异常入口的指令时arm指令，然后根据需要切换到thumb状态，在异常中断处理程序返回前，程序再切换到arm状态。
- 一条汇编指令可能对应多条thumb指令。
## 异常中断处理
### 异常中断概述
当异常中断发生时，系统执行完当前指令后，跳转到相应的异常中断处理程序处执行。当异常中断处理程序执行完成后，程序返回到发生中断指令的下一条指令处执行。在进入异常中断处理程序时，保存被中断的程序的执行现场，在从异常中断处理程序退出时，要恢复被中断的程序的执行现场。

### arm处理器对异常中断的响应过程
- 保存处理器当前状态，中断屏蔽为以及各个条件标志位。通过将当前的cpsr保存到要执行的模式的寄存器中，
- 将寄存器lr_mode设置成返回值
- 设置当前程序状态寄存器的cpsr中断响应的位，使处理器进入相应模式，切换状态到arm状态设置cpsr的位进制irq，当进入fiq时，禁止fiq中断。
- 将程序计数器PC设置成该异常中断的中断向量地址从而跳转到异常中断去处理。

### 从异常中断处理程序中返回
- 恢复中断的程序的处理器状态，即把SPSR_mode寄存器内容复制到当前程序状态寄存器CPSR中
- 返回发生异常中断指令的下一条指令，即把lr_mode寄存器的内容复制到程序计数器PC中。（复位中断不需要返回）

## FIQ和IRQ
- fiq中断优先级较高
- fiq多余的5个专用寄存器，进入中断时不需要保存那5个寄存器
- fiq中断向量表在向量表的最后。不需要额外的跳转指令。
- 当系统存在cache时，可以把fiq异常中断向量以及处理程序锁在cache中，从而大大缩短了fiq异常中断的响应时间

## 输入段的排序规则
- 连接器根据个输入段的属性来组织这些输入段，具有相同属性的输入段被放到域中一段连续的空间中，组成一个输出段。
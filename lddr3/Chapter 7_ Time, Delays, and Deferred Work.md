# Chapter 7: Time, Delays, and Deferred Work
- they have to deal with issues such as timing, memory management, hardware access, and more.
- time issues
> 1. Measuring time lapses and comparing times; 
> 2. Knowing the current time; 
> 3. Delaying operation for a specified amount of time; 
> 4. Scheduling asynchronous functions to happen at a later time
- Timer interrupts are generated by the system’s timing hardware at regular intervals; this interval is programmed at boot time by the kernel according to the value of HZ, which is an architecture-dependent value defined in <linux/param.h> or a subplatform file included by it. 改变HZ可以改变产生时钟中断的频率
- This is accomplished by calling the schedule function
```c
while (time_before(jiffies, j1)) {
    schedule( );//仅仅只是让出CPU，该进程还在runing队列中
}
```
- If your driver uses a wait queue to wait for some other event, but you also want to be sure that it runs within a certain period of time, it can use wait_event_timeout or wait_event_interruptible_timeout: These functions sleep on the given wait queue, but they return after the timeout (expressed in jiffies) expires. Thus, they implement a bounded sleep that does not go on forever. 
```c
#include <linux/wait.h>
long wait_event_timeout(wait_queue_head_t q, condition, long timeout);
long wait_event_interruptible_timeout(wait_queue_head_t q, condition, long timeout);
```
-  To accommodate for this very situation, where you want to delay execution waiting for no specific event, the kernel offers the schedule_timeout function so you can avoid declaring and using a superfluous wait queue head:
```c
#include <linux/sched.h>
signed long schedule_timeout(signed long timeout);
```
> *schedule_timeout* requires that the caller first set the current process state, so a typical call looks like:
```c
set_current_state(TASK_INTERRUPTIBLE);
schedule_timeout (delay);
```
> In the example just shown, the first line calls set_current_state to set things up so that the scheduler won’t run the current process again until the timeout places it back in TASK_RUNNING state. To achieve an uninterruptible delay, use TASK_UNINTERRUPTIBLE instead. If you forget to change the state of the current process, a call to schedule_timeout behaves like a call to schedule (i.e., the jitsched behavior), setting up a timer that is not used.

- The implementation of udelay (and possibly ndelay too) uses a software loop based on the processor speed calculated at boot time, using the integer variable loops_per_jiffy. If you want to look at the actual code, however, be aware that the x86 implementation is quite a complex one because of the different timing sources it uses, based on what CPU type is running the code.
- Whenever you need to schedule an action to happen later, without blocking the current process until that time arrives, kernel timers are the tool for you. 
- polling a device by checking its state at regular intervals when the hardware can’t fire interrupts.
- A kernel timer is a data structure that instructs the kernel to execute a user-defined function with a user-defined argument at a user-defined time. 
- When a timer runs, however, the process that scheduled it could be asleep, executing on a different processor, or quite possibly has exited altogether.
- In fact, kernel timers are run as the result of a “software interrupt.” When running in this sort of atomic context, your code is subject to a number of constraints. 
- A number of actions require the context of a process in order to be executed. When you are outside of process context (i.e., in interrupt context), you must observe the following rules:
> No access to user space is allowed. Because there is no process context, there is no path to the user space associated with any particular process.
> The current pointer is not meaningful in atomic mode and cannot be used since the relevant code has no connection with the process that has been interrupted.
> No sleeping or scheduling may be performed. Atomic code may not call schedule or a form of wait_event, nor may it call any other function that could sleep. For example, calling kmalloc(..., GFP_KERNEL) is against the rules. Semaphores also must not be used since they can sleep.
- Kernel code can tell if it is running in interrupt context by calling the function in_interrupt( ), which takes no parameters and returns nonzero if the processor is currently running in interrupt context, either hardware interrupt or software interrupt.
- A function related to in_interrupt() is in_atomic(). Its return value is nonzero whenever scheduling is not allowed; this includes hardware and software interrupt contexts as well as any time when a spinlock is held. 
- Tasklets
> - Tasklets resemble kernel timers in some ways.
> - you can’t ask to execute the function at a specific time. 
> - By scheduling a tasklet, you simply ask for it to be executed at a later time chosen by the kernel. 
> - all tasklet code must be atomic.
- Workqueues
  - some significant differences between the two, including:
  > - Tasklets run in software interrupt context with the result that all tasklet code must be atomic. Instead, workqueue functions run in the context of a special kernel process; as a result, they have more flexibility. In particular, workqueue functions can sleep.
  > - Tasklets always run on the processor from which they were originally submitted. Workqueues work in the same way, by default.
  > - Kernel code can request that the execution of workqueue functions be delayed for an explicit interval.